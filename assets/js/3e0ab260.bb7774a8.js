"use strict";(self.webpackChunk_mondrian_framework_docs=self.webpackChunk_mondrian_framework_docs||[]).push([[66],{876:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var r=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),m=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=m(e.components);return r.createElement(l.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=m(t),c=a,h=p["".concat(l,".").concat(c)]||p[c]||u[c]||i;return t?r.createElement(h,o(o({ref:n},d),{},{components:t})):r.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},707:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var r=t(7896),a=(t(2784),t(876));const i={},o="Definition",s={unversionedId:"docs/model/definition",id:"docs/model/definition",title:"Definition",description:"The @mondrian-framework/model package contains a wide range of useful functions for defining a data model schema, from the simplest type string to complex objects, arrays, and unions. The syntax used has been designed to make development straightforward and the schema as readable as possible.",source:"@site/docs/docs/model/01-definition.md",sourceDirName:"docs/model",slug:"/docs/model/definition",permalink:"/mondrian-framework/docs/docs/model/definition",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Model",permalink:"/mondrian-framework/docs/docs/model/"},next:{title:"Validation",permalink:"/mondrian-framework/docs/docs/model/validation"}},l={},m=[{value:"Primitives",id:"primitives",level:2},{value:"Advanced Types",id:"advanced-types",level:2},{value:"Custom types",id:"custom-types",level:2},{value:"Enums",id:"enums",level:2},{value:"Literals",id:"literals",level:2},{value:"Optional",id:"optional",level:2},{value:"Nullable",id:"nullable",level:2},{value:"Default",id:"default",level:2},{value:"Objects",id:"objects",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Unions",id:"unions",level:2},{value:"Select",id:"select",level:2},{value:"Merge",id:"merge",level:2},{value:"Recursion",id:"recursion",level:2}],d={toc:m},p="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(p,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"definition"},"Definition"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@mondrian-framework/model")," package contains a wide range of useful functions for defining a data model schema, from the simplest type ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," to complex objects, arrays, and unions. The syntax used has been designed to make development straightforward and the schema as readable as possible."),(0,a.kt)("h2",{id:"primitives"},"Primitives"),(0,a.kt)("p",null,"Mondrian Framework supports the definition of a really small, simple but powerfull range of primitive types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"m.boolean()\nm.string()\nm.number()\nm.integer()\nm.datetime() // ISO 8601\nm.timestamp() // unixtime (ms)\nm.null()\nm.void()\n")),(0,a.kt)("p",null,"Each of these can accept different params that can refine their semantics with some options, like common validation rules."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"m.string({ minLength: 5, maxLength: 256, regex: /^[1-9]\\d{0,2}$/g })\nm.number({ minimum: 0, maximum: 10000, multipleOf: 10 })\nm.integer({ minimum: 0, maximum: 10 })\nm.datetime({ minimum: new Date(2023, 0, 1), maximum: new Date() })\nm.timestamp({ minimum: new Date(2023, 0, 1), maximum: new Date() })\n")),(0,a.kt)("p",null,"Furthermore, each function allows for the possibility of setting a description parameter where useful text can be inserted for generating automatic documentation of the model."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},'const EmailAddress = m.string({ \n  regex: ^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$, \n  description: "A string representing a valid email address" \n})\n\nconst PositiveNumber = m.number({ \n  minimum: 0, \n  description: "A positive number" \n})\n')),(0,a.kt)("h2",{id:"advanced-types"},"Advanced Types"),(0,a.kt)("p",null,"Besides primitive types, the framework provides a wide range of utility types that are already implemented and ready to use. In order to minimize packages size and required dependencies, these advanced types are provided in a separate package named ",(0,a.kt)("inlineCode",{parentName:"p"},"@mondrian-framework/advanced-types"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import m from '@mondrian-framework/advanced-types'\n\n// DATE AND TIME RELATED\nm.date() // date string without time, ex: 2023-01-24\nm.time() // time only string RFC 3339, ex: 12:05:55Z\nm.timezone() // IANA Time Zone, ex: Europe/Rome\n\n// LOCATION RELATED\nm.countryCode() // ISO 3166-1 alpha-2, ex: IT\nm.latitude() \nm.longitude()\nm.locale() // ISO 639-1, ex: it\nm.currency() // ISO 4217, ex: EUR\n\n// OTHERS\nm.email() \nm.phoneNumber() // E.164 ex: +17895551234\nm.MAC() // IEEE 802 48-bit\nm.IP() // IPv4 or IPv6 address\nm.port() // TCP port\nm.version() // semantic version, ex: 1.1.2\nm.JWT() // JSON Web Token\nm.URL() // RFC 3986, ex: https://www.google.com\nm.UUID() // Universal Unique Identifier\nm.ISBN() // ISBN-10 or ISBN-13\nm.RGB() // CSS RGB, ex: rgb(255, 220, 200)\nm.RGBA() // CSS RGBA, ex: rgba(255, 220, 200, 0.5)\n")),(0,a.kt)("h2",{id:"custom-types"},"Custom types"),(0,a.kt)("p",null,"In addition to ",(0,a.kt)("a",{parentName:"p",href:"#primitives"},"primitive types"),", it is possible to define custom types with completely arbitrary logics. The mentioned ",(0,a.kt)("a",{parentName:"p",href:"#advanced-types"},"advanced types")," are built exactly in this way."),(0,a.kt)("p",null,"Below is an example implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"port")," type that represents a TCP port."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import { CustomTypeOpts, Result, number, integer, validate } from '@mondrian-framework/model'\n\nconst MIN_PORT_NUMBER = 0\nconst MAX_PORT_NUMBER = 65535\n\nexport function port(opts?: CustomTypeOpts) {\n  return m.custom(\n    {\n      name: 'port',\n      encodedType: number(),\n      decode: (input, opts, decodeOpts) => {\n        return { success: true, value: input }\n      },\n      encode: (input, opts) => {\n        return input\n      },\n      validate(input) {\n        const isInteger = validate(integer(), input)\n        if (!isInteger.success) {\n          return isInteger\n        }\n        const inputInteger = isInteger.value\n        if (inputInteger <= MIN_PORT_NUMBER || inputInteger > MAX_PORT_NUMBER) {\n          return Result.error(\n            `Invalid TCP port number ` +\n            `(must be between ${MIN_PORT_NUMBER + 1} and ${MAX_PORT_NUMBER})`,\n            input,\n          )\n        }\n        return Result.success(inputNumber)\n      },\n    },\n    opts,\n  )\n}\n")),(0,a.kt)("p",null,"Please note that the implementation of the custom type requires the definition of:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encodedType"),": which identifies the type representing this encoded custom type, typically in JSON format. In this specific case, the TCP port is a number."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"decode"),": a function that translates, if necessary, the encoded type into the internal type. In the example, no translation is needed because the TCP port is represented by a number in both the encoded and decoded models."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"encode"),": similar to decode, encode is a translation function from the internal type to the encoded type."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"validate"),': a validation function for the already decoded data, where custom and even complex rules can be added."')),(0,a.kt)("p",null,"A custom type can be used exactly as a primitive, simply calling its definition function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import { m } from '@mondrian-framework/model'\n// highlight-start\nimport { port } from './port'\n// highlight-end\n\nconst NetworkAddress = m.object({\n  ip: m.string(),\n  // highlight-start\n  port: port(),\n  // highlight-end\n})\n")),(0,a.kt)("h2",{id:"enums"},"Enums"),(0,a.kt)("p",null,"Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. Mondrian provides only string-based enums."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const UserType = m.enum(['CUSTOMER', 'ADMIN'])\n")),(0,a.kt)("h2",{id:"literals"},"Literals"),(0,a.kt)("p",null,"Literals represent ",(0,a.kt)("em",null,"specific")," strings or numbers in type positions. They are a common construct in the TypeScript language."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const Zero = m.literal(0)\nconst Hello = m.literal('Hello')\n")),(0,a.kt)("h2",{id:"optional"},"Optional"),(0,a.kt)("p",null,"You can make any type optional with an ",(0,a.kt)("inlineCode",{parentName:"p"},"optional()")," decorator. This means that the given type can be also ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),", or not specified if assigned to a field of an ",(0,a.kt)("a",{parentName:"p",href:"#objects"},"object"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const OptionalString = m.optional(m.string())\n")),(0,a.kt)("p",null,"For convenience, you can also call the ",(0,a.kt)("inlineCode",{parentName:"p"},"optional()")," method on an existing type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const OptionalString = m.string().optional()\n")),(0,a.kt)("h2",{id:"nullable"},"Nullable"),(0,a.kt)("p",null,"Similarly, you can make any type nullable with a ",(0,a.kt)("inlineCode",{parentName:"p"},"nullable()")," decorator. This means that the given type can be also ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// two equivalent defintions\nconst NullableString = m.nullable(m.string())\nconst NullableString = m.string().nullable()\n")),(0,a.kt)("h2",{id:"default"},"Default"),(0,a.kt)("p",null,"Another useful feature is the ",(0,a.kt)("inlineCode",{parentName:"p"},".default()")," decorator, that can receive a value or a function parameter. The default value is applied during the ",(0,a.kt)("a",{parentName:"p",href:"/mondrian-framework/docs/docs/model/decode"},"decode")," phase if the input of the decorated type is ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { m, decode } from '@mondrian-framework/model'\n\nconst NumberDefaultZero = m.number().default(0)\nconst NumberDefaultRandom = m.number().default(Math.random)\n\nm.decode(NumberDefaultZero, undefined) // => 0\nm.decode(NumberDefaultRandom, undefined) // => 0.4413456736055323\n")),(0,a.kt)("h2",{id:"objects"},"Objects"),(0,a.kt)("p",null,"Objects are structured types with a set of fields, required by default."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  email: m.string().optional(),\n  dateOfBirth: m.datetime().optional(),\n})\n")),(0,a.kt)("p",null,"Fields can be ",(0,a.kt)("a",{parentName:"p",href:"#primitives"},"primitive types"),", as in the previous example, ",(0,a.kt)("a",{parentName:"p",href:"#advanced-types"},"advanced types"),", ",(0,a.kt)("a",{parentName:"p",href:"#custom-types"},"custom types")," or other objects. In the latter case, they can be declared separately to be used multiple times or inline."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"// highlight-start\nconst Address = m.object({\n  street: m.integer(),\n  city: m.string(),\n  zipcode: m.string(),\n  country: m.string(),\n})\n// highlight-end\n\nconst User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  email: m.string().optional(),\n  dateOfBirth: m.datetime(.optional()),\n  // highlight-start\n  credentials: m.object({\n    username: m.string(),\n    password: m.password(),\n  }),\n  address: Address.optional(),\n  // highlight-end\n})\n")),(0,a.kt)("h2",{id:"arrays"},"Arrays"),(0,a.kt)("p",null,"Arrays are managed through a decorator that accept an optional parameter that defines maximum number of allowed elements."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0}," // two equivalent defintions\nconst ArrayOfStrings = m.array(m.string())\nconst ArrayOfStrings = m.string().array()\n\nconst ArrayOfMaxFiveStrings = m.string().array({ maxItems: 5 })\n\nconst User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  // highlight-start\n  emails: m.string().array(),\n  // highlight-end\n})\n")),(0,a.kt)("p",null,"Combining the ",(0,a.kt)("inlineCode",{parentName:"p"},"array")," decorator with others like ",(0,a.kt)("inlineCode",{parentName:"p"},"optional"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"nullable"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," assumes different meanings depending on the order in which they are applied. Note, for example, the following two cases: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import { m, decode } from '@mondrian-framework/model'\n\nconst NullableArrayOfStrings = m.string().array().nullable()\nconst ArrayOfNullableStrings = m.string().nullable().array()\n\ndecode(NullableArrayOfStrings, null) // => null\ndecode(NullableArrayOfStrings, [null]) // => error\n\ndecode(ArrayOfNullableStrings, null) // => error\ndecode(ArrayOfNullableStrings, [null]) // => [null]\n")),(0,a.kt)("h2",{id:"unions"},"Unions"),(0,a.kt)("p",null,"Mondrian provides an union function that allows you to compose multiple types with an ",(0,a.kt)("inlineCode",{parentName:"p"},"or")," semantics."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},'const StringOrNumber = m.union({ string: m.string(), number: m.number() })\n\nm.validate(StringOrNumber, "a string").success // => true\nm.validate(StringOrNumber, 10).success // => true\nm.validate(StringOrNumber, true).success // => false\n')),(0,a.kt)("p",null,"Every element of the union must be named in order to support advanced functionalities like ",(0,a.kt)("a",{parentName:"p",href:"/mondrian-framework/docs/docs/model/projection"},"projections"),". "),(0,a.kt)("p",null,"You can also combine complex types like objects or custom types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const OldBook = m.object({\n  id: m.string(),\n  title: m.string(),\n  type: m.literal('OLD'),\n  historicalPeriod: m.string(),\n})\n\nconst NewBook = m.object({\n  id: m.string(),\n  title: m.string(),\n  type: m.literal('NEW'),\n  publicationDate: m.datetime(),\n})\n\nconst SearchResult = m.union({ oldBook: OldBook, newBook: NewBook })\n")),(0,a.kt)("p",null,"In the union of two or more objects, it is often useful to specify explicit logic to identify which type of the union a value belongs to. This specification can be defined using the options parameter."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const SearchResult = m.union(\n  { oldBook: OldBook, newBook: NewBook },\n  {\n    requiredProjection: {\n      oldBook: { type: true },\n      newBook: { type: true },\n    },\n    is: {\n      oldBook: (v) => v.type === 'OLD',\n      newBook: (v) => v.type === 'NEW'\n    }\n  }  \n)\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"requiredProjection")," parameter identifies the necessary ",(0,a.kt)("a",{parentName:"p",href:"/mondrian-framework/docs/docs/model/projection"},"projection")," for each type of the union in order to have the fields necessary to discriminate one type from another. The ",(0,a.kt)("inlineCode",{parentName:"p"},"is")," functions, on the other hand, implement the logic that defines when a value is of a specific type."),(0,a.kt)("h2",{id:"select"},"Select"),(0,a.kt)("p",null,"Sometimes it is useful to define a type based on another one, selecting certain fields so as not to have to rewrite them. To do this, a utility function is provided, as shown in the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  email: m.string().optional(),\n})\n\n// highlight-start\nconst UserRequired = m.select(\n  User, \n  {\n    name: true,\n    surname: true\n  },\n)\n// highlight-end\n")),(0,a.kt)("h2",{id:"merge"},"Merge"),(0,a.kt)("p",null,"In the same way, it can be useful to merge two types and obtain a third type whose fields are the union of the two starting types. Together with the previously described function, this allows for the composition and decomposition of types as desired."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n})\n\nconst UserRequired = m.select(\n  User, \n  {\n    name: true,\n    surname: true\n  },\n)\n\n// highlight-start\nconst UserRegisterInput = m.merge(\n  UserRequired, \n  m.object({\n    password: m.string()\n  }),\n)\n// highlight-end\n")),(0,a.kt)("h2",{id:"recursion"},"Recursion"),(0,a.kt)("p",null,"The framework supports the definition of recursive types and complex circular chains of relationships. To achieve this, it is necessary to define types lazily, which is considered an overall best practice."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"lazy")," definition of a type is simple and involves defining a simple wrapper function, as shown in the following example. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const String = m.string()\nconst LazyString = () => String\n")),(0,a.kt)("p",null,"Using lazy types allows them to be referred, as functions, in the definition of themselves or other types, without any constraints on the sequentiality of the code writing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"export const User = () =>\n  t.object({\n    id: Id,\n    name: t.string(),\n    // highlight-start\n    parent: t.relation(t.array(User)), // relation to itself\n    posts: t.relation(t.array(Post)), // before Post declaration\n    // highlight-end\n  })\nexport type User = t.Infer<typeof User>\n\nexport const Post = () =>\n  t.object({\n    id: Id,\n    title: t.string(),\n    content: t.string(),\n    author: t.relation(User),\n  })\nexport type Post = t.Infer<typeof Post>\n")))}u.isMDXComponent=!0}}]);