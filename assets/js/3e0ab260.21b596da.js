"use strict";(self.webpackChunk_mondrian_framework_docs=self.webpackChunk_mondrian_framework_docs||[]).push([[66],{876:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),m=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=m(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=m(t),c=r,g=u["".concat(l,".").concat(c)]||u[c]||p[c]||i;return t?a.createElement(g,o(o({ref:n},d),{},{components:t})):a.createElement(g,o({ref:n},d))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var m=2;m<i;m++)o[m]=t[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},707:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var a=t(7896),r=(t(2784),t(876));const i={},o="Definition",s={unversionedId:"docs/model/definition",id:"docs/model/definition",title:"Definition",description:"The @mondrian-framework/model package contains a wide range of useful functions for defining a data model schema, from the simplest type string to complex objects, arrays, and unions. The syntax used has been designed to make development straightforward and the schema as readable as possible.",source:"@site/docs/docs/model/01-definition.md",sourceDirName:"docs/model",slug:"/docs/model/definition",permalink:"/mondrian-framework/docs/docs/model/definition",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"docsSidebar",previous:{title:"Model",permalink:"/mondrian-framework/docs/docs/model/"},next:{title:".is()",permalink:"/mondrian-framework/docs/docs/model/is"}},l={},m=[{value:"Primitives",id:"primitives",level:2},{value:"Advanced Types",id:"advanced-types",level:2},{value:"Custom types",id:"custom-types",level:2},{value:"Enums",id:"enums",level:2},{value:"Literals",id:"literals",level:2},{value:"Optional",id:"optional",level:2},{value:"Nullable",id:"nullable",level:2},{value:"Default",id:"default",level:2},{value:"Objects",id:"objects",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Unions",id:"unions",level:2},{value:"Reference",id:"reference",level:2},{value:"Select",id:"select",level:2},{value:"Merge",id:"merge",level:2},{value:"Recursion",id:"recursion",level:2}],d={toc:m},u="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"definition"},"Definition"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@mondrian-framework/model")," package contains a wide range of useful functions for defining a data model schema, from the simplest type ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," to complex objects, arrays, and unions. The syntax used has been designed to make development straightforward and the schema as readable as possible."),(0,r.kt)("h2",{id:"primitives"},"Primitives"),(0,r.kt)("p",null,"Mondrian Framework supports the definition of a really small, simple but powerfull range of primitive types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"m.boolean()\nm.string()\nm.number()\nm.integer()\nm.datetime() // ISO 8601\nm.timestamp() // unixtime (ms)\nm.null()\nm.void()\n")),(0,r.kt)("p",null,"Each of these can accept different params that can refine their semantics with some options, like common validation rules."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"m.string({ minLength: 5, maxLength: 256, regex: /^[1-9]\\d{0,2}$/g })\nm.number({ minimum: 0, maximum: 10000, multiplierOf: 10 })\nm.integer({ minimum: 0, maximum: 10 })\nm.datetime({ minimum: new Date(2023, 0, 1), maximum: new Date() })\nm.timestamp({ minimum: new Date(2023, 0, 1), maximum: new Date() })\n")),(0,r.kt)("p",null,"Furthermore, each function allows for the possibility of setting a description parameter where useful text can be inserted for generating automatic documentation of the model."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},'const EmailAddress = m.string({ \n  regex: ^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$, \n  description: "A string representing a valid email address" \n})\n\nconst PositiveNumber = m.number({ \n  minimum: 0, \n  description: "A positive number" \n})\n')),(0,r.kt)("h2",{id:"advanced-types"},"Advanced Types"),(0,r.kt)("p",null,"Besides primitive types, the framework provides a wide range of utility types that are already implemented and ready to use. In order to minimize packages size and required dependencies, these advanced types are provided in a separate package named ",(0,r.kt)("inlineCode",{parentName:"p"},"@mondrian-framework/advanced-types"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import m from '@mondrian-framework/advanced-types'\n\n// DATE AND TIME RELATED\nm.date() // date string without time, ex: 2023-01-24\nm.time() // time only string RFC 3339, ex: 12:05:55Z\nm.timezone() // IANA Time Zone, ex: Europe/Rome\n\n// LOCATION RELATED\nm.countryCode() // ISO 3166-1 alpha-2, ex: IT\nm.latitude() \nm.longitude()\nm.locale() // ISO 639-1, ex: it\nm.currency() // ISO 4217, ex: EUR\n\n// OTHERS\nm.email() \nm.phoneNumber() // E.164 ex: +17895551234\nm.MAC() // IEEE 802 48-bit\nm.IP() // IPv4 or IPv6 address\nm.port() // TCP port\nm.version() // semantic version, ex: 1.1.2\nm.JWT() // JSON Web Token\nm.URL() // RFC 3986, ex: https://www.google.com\nm.UUID() // Universal Unique Identifier\nm.ISBN() // ISBN-10 or ISBN-13\nm.RGB() // CSS RGB, ex: rgb(255, 220, 200)\nm.RGBA() // CSS RGBA, ex: rgba(255, 220, 200, 0.5)\n")),(0,r.kt)("h2",{id:"custom-types"},"Custom types"),(0,r.kt)("h2",{id:"enums"},"Enums"),(0,r.kt)("p",null,"Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. Mondrian provides only string-based enums."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const UserType = m.enum(['CUSTOMER', 'ADMIN'])\n")),(0,r.kt)("h2",{id:"literals"},"Literals"),(0,r.kt)("p",null,"Literals represent ",(0,r.kt)("em",null,"specific")," strings or numbers in type positions. They are a common construct in the TypeScript language."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const Zero = m.literal(0)\nconst Hello = m.literal('Hello')\n")),(0,r.kt)("h2",{id:"optional"},"Optional"),(0,r.kt)("p",null,"You can make any type optional with an ",(0,r.kt)("inlineCode",{parentName:"p"},"optional()")," decorator. This means that the given type can be also ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", or not specified if assigned to a field of an ",(0,r.kt)("a",{parentName:"p",href:"#objects"},"object"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const OptionalString = m.optional(m.string())\n")),(0,r.kt)("p",null,"For convenience, you can also call the ",(0,r.kt)("inlineCode",{parentName:"p"},"optional()")," method on an existing type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const OptionalString = m.string().optional()\n")),(0,r.kt)("h2",{id:"nullable"},"Nullable"),(0,r.kt)("p",null,"Similarly, you can make any type nullable with a ",(0,r.kt)("inlineCode",{parentName:"p"},"nullable()")," decorator. This means that the given type can be also ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// two equivalent defintions\nconst NullableString = m.nullable(m.string())\nconst NullableString = m.string().nullable()\n")),(0,r.kt)("h2",{id:"default"},"Default"),(0,r.kt)("p",null,"Another useful feature is the ",(0,r.kt)("inlineCode",{parentName:"p"},".default()")," decorator, that can receive a value or a function parameter. The default value is applied during the ",(0,r.kt)("a",{parentName:"p",href:"/mondrian-framework/docs/docs/model/decode"},"decode")," phase if the input of the decorated type is ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { m, decode } from '@mondrian-framework/model'\n\nconst NumberDefaultZero = m.number().default(0)\nconst NumberDefaultRandom = m.number().default(Math.random)\n\nm.decode(NumberDefaultZero, undefined) // => 0\nm.decode(NumberDefaultRandom, undefined) // => 0.4413456736055323\n")),(0,r.kt)("h2",{id:"objects"},"Objects"),(0,r.kt)("p",null,"Objects are structured types with a set of fields, required by default."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"const User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  email: m.string().optional(),\n  dateOfBirth: m.datetime().optional(),\n})\n")),(0,r.kt)("p",null,"Fields can be ",(0,r.kt)("a",{parentName:"p",href:"#primitives"},"primitive types"),", as in the previous example, ",(0,r.kt)("a",{parentName:"p",href:"#advanced-types"},"advanced types"),", ",(0,r.kt)("a",{parentName:"p",href:"#custom-types"},"custom types")," or other objects. In the latter case, they can be declared separately to be used multiple times or inline."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"// highlight-start\nconst Address = m.object({\n  street: m.integer(),\n  city: m.string(),\n  zipcode: m.string(),\n  country: m.string(),\n})\n// highlight-end\n\nconst User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  email: m.string().optional(),\n  dateOfBirth: m.datetime(.optional()),\n  // highlight-start\n  credentials: m.object({\n    username: m.string(),\n    password: m.password(),\n  }),\n  address: Address.optional(),\n  // highlight-end\n})\n")),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays are managed through a decorator that accept an optional parameter that defines maximum number of allowed elements."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0}," // two equivalent defintions\nconst ArrayOfStrings = m.array(m.string())\nconst ArrayOfStrings = m.string().array()\n\nconst ArrayOfMaxFiveStrings = m.string().array({ maxItems: 5 })\n\nconst User = m.object({\n  id: m.integer(),\n  name: m.string(),\n  surname: m.string(),\n  // highlight-start\n  emails: m.string().array(),\n  // highlight-end\n})\n")),(0,r.kt)("p",null,"Combining the ",(0,r.kt)("inlineCode",{parentName:"p"},"array")," decorator with others like ",(0,r.kt)("inlineCode",{parentName:"p"},"optional"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nullable"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," assumes different meanings depending on the order in which they are applied. Note, for example, the following two cases: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"showLineNumbers",showLineNumbers:!0},"import { m, decode } from '@mondrian-framework/model'\n\nconst NullableArrayOfStrings = m.string().array().nullable()\nconst ArrayOfNullableStrings = m.string().nullable().array()\n\ndecode(NullableArrayOfStrings, null) // => null\ndecode(NullableArrayOfStrings, [null]) // => error\n\ndecode(ArrayOfNullableStrings, null) // => error\ndecode(ArrayOfNullableStrings, [null]) // => [null]\n")),(0,r.kt)("h2",{id:"unions"},"Unions"),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("h2",{id:"select"},"Select"),(0,r.kt)("h2",{id:"merge"},"Merge"),(0,r.kt)("h2",{id:"recursion"},"Recursion"))}p.isMDXComponent=!0}}]);